1 . new 、 delete 、 malloc 、 free 关系 
 delete 会 调用 对象 的 析构 函数 , 和 new 对应 free 只会 释放 内存 ， new 调用 构造函数 。 malloc 与 free 是 C++ / C语言 的 标准 库函数 ， new / delete 是 C++ 的 运算符 。 它们 都 可 用于 申请 动态内存 和 释放 内存 。 对于 非 内部 数据类型 的 对象 而言 ， 光用 malloc / free 无法 满足 动态 对象 的 要求 。 对象 在 创建 的 同时 要 自动 执行 构造函数 ， 对象 在 消亡 之前 要 自动 执行 析构 函数 。 由于 malloc / free 是 库函数 而 不是 运算符 ， 不 在 编译器 控制 权限 之内 ， 不 能够 把 执行 构造函数 和析构 函数 的 任务 强加于 malloc / free 。 因此 C++ 语言 需要 一个 能 完成 动态内存 分配 和 初始化 工作 的 运算符 new ， 以及 一个 能 完成 清理 与 释放 内存 工作 的 运算符 delete 。 注意 new / delete 不是 库函数 。 
 2 . New   delete   与 malloc   free   的 联系 与 区别 ? 
 答案 ： 都 是 在 堆 ( heap ) 上 进行 动态 的 内存 操作 。 用 malloc 函数 需要 指定 内存 分配 的 字节数 并且 不能 初始化 对象 ， new   会 自动 调用 对象 的 构造函数 。 delete   会 调用 对象 的 destructor ， 而 free   不会 调用 对象 的 destructor . 
 3 . delete 与   delete   [ ] 区别 
 delete 只会 调用 一次 析构 函数 ， 而 delete [ ] 会 调用 每 一个 成员 的 析构 函数 。 在 More   Effective     C++ 中有 更为 详细 的 解释 ： “ 当 delete 操作符 用于 数组 时 ， 它 为 每个 数组 元素 调用 析构 函数 ， 然后 调用 operator   delete 来 释放 内存 。 ” delete 与 New 配套 ， delete   [ ] 与 new   [ ] 配套 
     MemTest * mTest1 = new   MemTest [ 10 ] ; 
     MemTest * mTest2 = new   MemTest ; 
     int * pInt1 = new   int [ 10 ] ; 
     int * pInt2 = new   int ; 
     delete [ ] pInt1 ;     
     delete [ ] pInt2 ;     
     delete [ ] mTest1 ; 
     delete [ ] mTest2 ; 
     在 4 处 报错 。 
 这 就 说明 ： 对于 内 建 简单 数据类型 ， delete 和 delete [ ] 功能 是 相同 的 。 对于 自定义 的 复杂 数据类型 ， delete 和 delete [ ] 不能 互用 。 delete [ ] 删除 一个 数组 ， delete 删除 一个 指针 简单 来说 ， 用 new 分配 的 内存 用 delete 删除 ， 用 new [ ] 分配 的 内存 用 delete [ ] 删除 ， delete [ ] 会 调用 数组 元素 的 析构 函数 。 内部 数据类型 没有 析构 函数 ， 所以 问题 不 大 。 如果 你 在 用 delete 时 没用 括号 ， delete 就 会 认为 指向 的 是 单个 对象 ， 否则 ， 它 就 会 认为 指向 的 是 一个 数组 。 
 4 . C++ 有 哪些 性质 （ 面向对象 特点 ） 
 封装 ， 继承 和 多态 。 
 在 面向对象 程序设计 语言 中 ， 封装 是 利用 可 重用 成分 构造 软件系统 的 特性 ， 它 不仅 支持系统 的 可 重用 性 ， 而且 还 有利于 提高 系统 的 可扩充性 ； 消息传递 可以 实现 发送 一个 通用 的 消息 而 调用 不同 的 方法 ； 封装 是 实现 信息隐蔽 的 一种 技术 ， 其 目的 是 使类 的 定义 和 实现 分离 。 
 5 . 子类 析构 时要 调用 父类 的 析构 函数 吗 ？ 
 析构 函数调用 的 次序 是 先 派生类 的 析 构后 基类 的 析构 ， 也就是说 在 基类 的 的 析构 调用 的 时候 , 派生类 的 信息 已经 全部 销毁 了 定义 一个 对象 时先 调用 基类 的 构造函数 、 然后 调用 派生类 的 构造函数 ； 析构 的 时候 恰好相反 ： 先 调用 派生类 的 析构 函数 、 然后 调用 基类 的 析构 函数 。 
 
 6 . 拷贝 构造函数 为什么 要 使用 引用 而 不是 值 传递 ？ 
 复制 构造函数 的 形式 : 
 CImg   ( const   CImg &   obj ) ; 它 接受 一个 指向 类 对象 的 常量 引用 作为 参数 。 定义 为   const   是 必须 的 , 因为 复制 构造函数 只是 复制 对象 , 所以 没 必要 改变 传递 来 的 对象 的 值 , 声明 为 引用   可以 节省时间 , 如果 是 按值 传递 的 ， 会 生成 对象 的 副本 , 会 浪费资源 , 而 引用 就 不会 。 
 对象 多次 初始化 ， 会 递归 触发 拷贝 构造函数 。 当 按值 传递 对象 时 ， 会 创建 一个 形参 的 临时 对象 , 然后 调用 复制 构造函数 把 临时 对象 的 值 复制 给 实参 。 临时 对象 消失 时会 调用 相应 的 析构 函数 。 
 7 . C++ 对象 初始化 和 赋值 
 对象 的 初始化 与 对象 的 赋值 是 不同 的 概念 。 C++ 编译器 分别 调用 的 是 拷贝 构造函数 和 等 号 操作符 。 在 C++ 中 ， 当 一个 新 对象 被 创建 时 ， 会 有 初始化 操作 ； 而 赋值 是 修改 一个 已经 存在 的 对象 的 值 。 初始化 操作 由 构造函数 完成 ， 而 赋值 操作 由 operator = 操作符 函数 完成 。 如果 程序员 没有 提供 构造函数 和 operator = 操作符 函数 ， 那么 编译器 会 提供 缺省 版本 。 
 对象 的 赋值 ： 调用 的 是 C++ 自带 的 operator   =   ( )   或者 用户 重载 的 等 号 操作 函数 。 
 对象 初始化 ： 使用 缺省 构造函数 或缺 省 复制 构造函数 。 
 CDummy   d1 ;   / / 初始化 ， 无参 构造函数 被 调用 
 CDummy   d3 ( d1 ) ;     / / 初始化 ， 复制 构造函数 被 调用 
 CDummy   d2   =   d1 ;     / / 初始化 ， 复制 构造函数 被 调用 
 d3   =   d1 ;   / /   对象 赋值 ， operator = 操作符 函数 被 调用 
 8 . 命名 空间 的 使用 
 有 三种 ： 作用域 解析 运算符 （ : : ） ， using 指令 （ using   namespace ） 和 using 声明 。 
 使用 using 声明 会 更 安全 。 因为 ， using 声明 只 导入 指定 的 名称 ， 如果 该 名称 与 局部 名称 发生冲突 ， 编译器 会 报错 。 而 using 指令 导入 整个 命名 空间 中 的 所有 成员 的 名称 ， 包括 那些 可能 根本 用 不到 的 名称 ， 如果 其中 有 名称 与 局部 名称 发生冲突 ， 则 编译器 并 不会 发出 任何 警告 信息 ， 而 只是 用 局部 名去 自动 覆盖 命名 空间 中 的 同名 成员 。 
 9 . 多态 ， 虚 函数 ， 纯虚 函数 
 多态 ： 是 对于 不同 对象 接收 相同 消息 时 产生 不同 的 动作 。 C++ 的 多态性 具体 体现 在 运行 和 编译 两个 方面 ： 在 程序运行 时 的 多态性 通过 继承 和 虚 函数 来 体现 ； 
 在 程序 编译 时 多态性 体现 在 函数 和 运算符 的 重载 上 
 虚 函数 ： 在 基类 中 冠以 关键字   virtual   的 成员 函数 。   它 提供 了 一种 接口界面 。 允许 在 派生类 中 对 基类 的 虚 函数 重新 定义 。 
 纯虚 函数 的 作用 ： 在 基类 中为 其 派生类 保留 一个 函数 的 名字 ， 以便 派生类 根据 需要 对 它 进行 定义 。 作为 接口 而 存在   纯虚 函数 不 具备 函数 的 功能 ， 一般 不能 直接 被 调用 。 
 从 基类 继承 来 的 纯虚 函数 ， 在 派生类 中 仍 是 虚 函数 。 如果 一个 类中 至少 有 一个 纯虚 函数 ， 那么 这个 类 被 称为 抽象类 （ abstract   class ） 。 
 抽象类 中 不仅 包括 纯虚 函数 ， 也 可 包括 虚 函数 。 l 抽象类 必须 用作 派生 其他 类 的 基类 ， 而 不能 用于 直接 创建对象 实例 。 但 仍 可 使用 指向 抽象类 的 指针 支持 运行 时 多态性 。 
 10 . 什么 是 “ 引用 ” ？ 声明 和 使用 “ 引用 ” 要 注意 哪些 问题 ？ 
 引用 就是 某个 目标 变量 的 “ 别名 ” ( alias ) ， 对 应用 的 操作 与 对 变量 直接 操作 效果 完全相同 。 声明 一个 引用 的 时候 ， 切记 要 对 其 进行 初始化 。 引用 声明 完毕 后 ， 相当于 目标 变量名 有 两个 名称 ， 即该 目标 原 名称 和 引用 名 ， 不能 再 把 该 引用 名 作为 其他 变量名 的 别名 。 声明 一个 引用 ， 不是 新 定义 了 一个 变量 ， 它 只 表示 该 引用 名是 目标 变量名 的 一个 别名 ， 它 本身 不是 一种 数据类型 ， 因此 引用 本身 不 占 存储单元 ， 系统 也 不 给 引用 分配 存储单元 。 不能 建立 数组 的 引用 。 
 12 . 将 “ 引用 ” 作为 函数参数 有 哪些 特点 ？ 
 （ 1 ） 传递 引用 给 函数 与 传递 指针 的 效果 是 一样 的 。 这时 ， 被 调 函数 的 形参 就 成为 原来 主调 函数 中 的 实 参变量 或 对象 的 一个 别名 来 使用 ， 所以 在 被 调 函数 中对形 参变量 的 操作 就是 对 其 相应 的 目标 对象 （ 在 主调 函数 中 ） 的 操作 。 
 （ 2 ） 使用 引用 传递函数 的 参数 ， 在 内存 中 并 没有 产生 实参 的 副本 ， 它 是 直接 对 实参 操作 ； 而 使用 一般 变量 传递函数 的 参数 ， 当 发生 函数调用 时 ， 需要 给 形参 分配 存储单元 ， 形 参变量 是 实 参变量 的 副本 ； 如果 传递 的 是 对象 ， 还 将 调用 拷贝 构造函数 。 因此 ， 当 参数传递 的 数据 较大 时 ， 用 引用 比用 一般 变量 传递 参数 的 效率 和 所 占 空间 都 好 。 
 （ 3 ） 使用 指针 作为 函数 的 参数 虽然 也 能 达到 与 使用 引用 的 效果 ， 但是 ， 在 被 调 函数 中 同样 要 给 形参 分配 存储单元 ， 且 需要 重复使用 " * 指针 变量名 " 的 形式 进行 运算 ， 这 很 容易 产生 错误 且 程序 的 阅读 性 较差 ； 另一方面 ， 在 主调 函数 的 调用 点处 ， 必须 用 变量 的 地址 作为 实参 。 而 引用 更 容易 使用 ， 更 清晰 。 
 13 . 在 什么 时候 需要 使用 “ 常 引用 ” ？ 
 如果 既 要 利用 引用 提高 程序 的 效率 ， 又 要 保护 传递 给 函数 的 数据 不 在 函数 中 被 改变 ， 就 应 使用 常 引用 。 常 引用 声明 方式 ： const   类型 标识符   & 引用 名 = 目标 变量名 ； 
 14 . 将 “ 引用 ” 作为 函数 返回值 类型 的 格式 、 好处 和 需要 遵守 的 规则 ? 
 格式 ： 类型 标识符   & 函数 名 （ 形参 列表 及 类型 说明 ） {   / / 函数 体   } 
 好处 ： 在 内存 中 不 产生 被 返回值 的 副本 ； （ 注意 ： 正是 因为 这点 原因 ， 所以 返回 一个 局部变量 的 引用 是 不 可取 的 。 因为 随着 该 局部变量 生存期 的 结束 ， 相应 的 引用 也 会 失效 ， 产生 runtime   error !   注意事项 ： 
 （ 1 ） 不能 返回 局部变量 的 引用 。 这 条 可以 参照 Effective   C++ [ 1 ] 的 Item   31 。 主要 原因 是 局部变量 会 在 函数 返回 后 被 销毁 ， 因此 被 返回 的 引用 就 成为 了 " 无 所指 " 的 引用 ， 程序 会 进入 未知 状态 。 
 （ 2 ） 不能 返回 函数 内部 new 分配 的 内存 的 引用 。 这 条 可以 参照 Effective   C++ [ 1 ] 的 Item   31 。 虽然 不 存在 局部变量 的 被动 销毁 问题 ， 可 对于 这种 情况 （ 返回 函数 内部 new 分配内存 的 引用 ） ， 又 面临 其它 尴尬 局面 。 例如 ， 被 函数 返回 的 引用 只是 作为 一个 临时 变量 出现 ， 而 没有 被 赋予 一个 实际 的 变量 ， 那么 这个 引用 所 指向 的 空间 （ 由 new 分配 ） 就 无法 释放 ， 造成 memory   leak 。 
 （ 3 ） 可以 返回 类 成员 的 引用 ， 但 最好 是 const 。 这 条 原则 可以 参照 Effective   C++ [ 1 ] 的 Item   30 。 主要 原因 是 当 对象 的 属性 是 与 某种 业务 规则 （ business   rule ） 相关联 的 时候 ， 其 赋值 常常 与 某些 其它 属性 或者 对象 的 状态 有关 ， 因此 有 必要 将 赋值 操作 封装 在 一个 业务 规则 当中 。 如果 其它 对象 可以 获得 该 属性 的 非常 量 引用 （ 或 指针 ） ， 那么 对 该 属性 的 单纯 赋值 就 会 破坏 业务 规则 的 完整性 。 
 （ 4 ） 流 操作符 重载 返回值 声明 为 “ 引用 ” 的 作用 ： 
 流 操作符 < < 和 > > ， 这 两个 操作符 常常 希望 被 连续 使用 ， 例如 ： cout   < <   " hello "   < <   endl ; 　 因此 这 两个 操作符 的 返回值 应该 是 一个 仍然 支持 这 两个 操作符 的 流 引用 。 可选 的 其它 方案 包括 ： 返回 一个 流 对象 和 返回 一个 流 对象 指针 。 但是 对于 返回 一个 流 对象 ， 程序 必须 重新 （ 拷贝 ） 构造 一个 新 的 流 对象 ， 也就是说 ， 连续 的 两个 < < 操作符 实际上 是 针对 不同 对象 的 ！ 这 无法 让 人 接受 。 对于 返回 一个 流 指针 则 不能 连续 使用 < < 操作符 。 因此 ， 返回 一个 流 对象 引用 是 惟一 选择 。 这个 唯一 选择 很 关键 ， 它 说明 了 引用 的 重要性 以及 无可替代 性 ， 也许 这 就是 C++ 语言 中 引入 引用 这个 概念 的 原因 吧 。   赋值 操作符 = 。 这个 操作符 象流 操作符 一样 ， 是 可以 连续 使用 的 ， 例如 ： x   =   j   =   10 ; 或者 ( x = 10 ) = 100 ; 赋值 操作符 的 返回值 必须 是 一个 左值 ， 以便 可以 被 继续 赋值 。 因此 引用 成 了 这个 操作符 的 惟一 返回值 选择 。 
 15 . “ 引用 ” 与 多态 的 关系 ？ 
 引用 是 除 指针 外 另 一个 可以 产生 多态 效果 的 手段 。 这 意味着 ， 一个 基类 的 引用 可以 指向 它 的 派生类 实例 。 
 16 . “ 引用 ” 与 指针 的 区别 是 什么 ？ 
 指针 通过 某个 指针 变量 指向 一个 对象 后 ， 对 它 所 指向 的 变量 间接 操作 。 程序 中 使用 指针 ， 程序 的 可读性 差 ； 而 引用 本身 就是 目标 变量 的 别名 ， 对 引用 的 操作 就是 对 目标 变量 的 操作 。 此外 ， 就是 上面 提到 的 对 函数 传 ref 和 pointer 的 区别 。 
 17 . 什么 时候 需要 “ 引用 ” ？ 
 流 操作符 < < 和 > > 、 赋值 操作符 = 的 返回值 、 拷贝 构造函数 的 参数 、 赋值 操作符 = 的 参数 、 其它 情况 都 推荐 使用 引用 。 
 18 . 结构 与 联合 有 和 区别 ？ 
 ( 1 ) 结构 和 联合 都 是 由 多个 不同 的 数据类型 成员 组成 ,   但 在 任何 同一 时刻 ,   联合 中 只 存放 了 一个 被 选中 的 成员 （ 所有 成员 共用 一块 地址 空间 ） ,   而 结构 的 所有 成员 都 存在 （ 不同 成员 的 存放 地址 不同 ） 。   
 ( 2 ) 对于 联合 的 不同 成员 赋值 ,   将会 对 其它 成员 重写 ,   原来 成员 的 值 就 不 存在 了 ,   而 对于 结构 的 不同 成员 赋值 是 互不 影响 的 。 
 20 . 关联 、 聚合 ( Aggregation ) 以及 组合 ( Composition ) 的 区别 ？ 
 涉及 到 UML 中 的 一些 概念 ： 关联 是 表示 两个 类 的 一般性 联系 ， 比如 “ 学生 ” 和 “ 老师 ” 就是 一种 关联 关系 ； 聚合 表示 has - a 的 关系 ， 是 一种 相对 松散 的 关系 ， 聚合 类 不 需要 对 被 聚合 类 负责 ， 如下 图 所示 ， 用空 的 菱形 表示 聚合 关系 ： 从 实现 的 角度 讲 ， 聚合 可以 表示 为 : 
 class   A   { ... }     class   B   {   A *   a ;   ..... } 
 而 组合 表示 contains - a 的 关系 ， 关联性 强于 聚合 ： 组合 类 与 被 组合 类有 相同 的 生命周期 ， 组合 类要 对 被 组合 类 负责 ， 采用 实心 的 菱形 表示 组合 关系 ： 实现 的 形式 是 : 
 class   A { ... }   class   B {   A   a ;   ... } 
 21 . 重载 （ overload ) 和 重写 ( overried ， 有 的 书 也 叫做 “ 覆盖 ” ） 的 区别 ？ 
 从 定义 上 来说 ： 
 重载 ： 是 指 允许 存在 多个 同名 函数 ， 而 这些 函数 的 参数表 不同 （ 或许 参数 个数 不同 ， 或许 参数 类型 不同 ， 或许 两者 都 不同 ） 。 
 重写 ： 是 指 子类 重新 定 义父 类虚 函数 的 方法 。 
 从 实现 原理 上 来说 ： 
 重载 ： 编译器 根据 函数 不同 的 参数表 ， 对 同名 函数 的 名称 做 修饰 ， 然后 这些 同名 函数 就 成 了 不同 的 函数 （ 至少 对于 编译器 来说 是 这样 的 ） 。 如 ， 有 两个 同名 函数 ： function   func ( p : integer ) : integer ; 和 function   func ( p : string ) : integer ; 。 那么 编译器 做过 修饰 后 的 函数 名称 可能 是 这样 的 ： int _ func 、 str _ func 。 对于 这 两个 函数 的 调用 ， 在 编译器 间 就 已经 确定 了 ， 是 静态 的 。 也就是说 ， 它们 的 地址 在 编译 期 就 绑定 了 （ 早 绑定 ） ， 因此 ， 重载 和 多态 无关 ！ 
 重写 ： 和 多态 真正 相关 。 当 子类 重新 定义 了 父类 的 虚 函数 后 ， 父类 指针 根据 赋给 它 的 不同 的 子类 指针 ， 动态 的 调用 属于 子类 的 该 函数 ， 这样 的 函数调用 在 编译 期间 是 无法 确定 的 （ 调用 的 子类 的 虚 函数 的 地址 无法 给出 ） 。 因此 ， 这样 的 函数 地址 是 在 运行 期 绑定 的 （ 晚 绑定 ） 。 
 22 . 多态 的 作用 ？ 
 （ 1 ） 隐藏 实现 细节 ， 使得 代码 能够 模块化 ； 扩展 代码 模块 ， 实现 代码 重用 ； 
 （ 2 ） 接口 重用 ： 为了 类 在 继承 和 派生 的 时候 ， 保证 使用 家族 中任 一类 的 实例 的 某 一 属性 时 的 正确 调用 。 
 23 .# define   DOUBLE ( x )   x + x   ， i   =   5 * DOUBLE ( 5 ) ；   i   是 多少 ？ 
 答案 ： i   为 30 。 
 24 . 有 哪几种 情况 只能 用 intialization   list   而 不能 用 assignment ? 
 答案 ： 当类 中 含有 const 、 reference   成员 变量 ； 基类 的 构造函数 都 需要 初始化 表 。 
 25 . C++ 是不是 类型 安全 的 ？ 
 答案 ： 不是 。 两个 不同 类型 的 指针 之间 可以 强制 转换 （ 用 reinterpret   cast ) 。 C# 是 类型 安全 的 。 
 26 . main   函数 执行 以前 ， 还会 执行 什么 代码 ？ 
 答案 ： 全局 对象 的 构造函数 会 在 main   函数 之前 执行 。 
 27 . 描述 内存 分配 方式 以及 它们 的 区别 ? 
 1 ）   从 静态 存储 区域 分配 。 内 存在 程序 编译 的 时候 就 已经 分配 好 ， 这块 内 存在 程序 的 整个 运行 期间 都 存在 。 例如 全局变量 ， static   变量 。 
 2 ）   在 栈 上 创建 。 在 执行 函数 时 ， 函数 内 局部变量 的 存储单元 都 可以 在 栈 上 创建 ， 函数 执行 结束 时 这些 存储单元 自动 被 释放 。 栈 内存 分配 运算 内 置于 处理器 的 指令集 。 
 3 ）   从堆 上 分配 ， 亦 称 动态内存 分配 。 程序 在 运行 的 时候 用 malloc   或 new   申请 任意 多少 的 内存 ， 程序员 自己 负责 在 何时 用 free   或 delete   释放 内存 。 动态内存 的 生存期 由 程序员 决定 ， 使用 非常灵活 ， 但 问题 也 最 多 。 
 28 . Struct   和   class   的 区别 ？ 
 答案 ： struct   的 成员 默认 是 公有 的 ， 而类 的 成员 默认 是 私有 的 。 struct   和   class   在 其他 方面 是 功能 相当 的 。 从 感情 上 讲 ， 大多数 的 开发者 感到 类 和 结构 有 很大 的 差别 。 感觉 上 结构 仅仅 象 一堆 缺乏 封装 和 功能 的 开放 的 内存 位 ， 而类 就 象活 的 并且 可靠 的 社会 成员 ， 它 有 智能 服务 ， 有 牢固 的 封装 屏障 和 一个 良好 定义 的 接口 。 既然 大多数 人 都 这么 认为 ， 那么 只有 在 你 的 类 有 很少 的 方法 并且 有 公有 数据 （ 这种 事情 在 良好 设计 的 系统 中是 存在 的 ! ） 时 ， 你 也许 应该 使用   struct   关键字 ， 否则 ， 你 应该 使用   class   关键字 。 
 29 . 当 一个 类 A   中 没有 任何 成员 变量 与 成员 函数 , 这时 sizeof ( A ) 的 值 是 多少 ？ 
 答案 ： 如果 不是 零 ， 请 解释一下 编译器 为什么 没有 让 它 为 零 。 （ Autodesk ） 肯定 不是 零 。 举个 反例 ， 如果 是 零 的话 ， 声明 一个 class   A [ 10 ] 对象 数组 ， 而 每 一个 对象 占用 的 空间 是 零 ， 这时 就 没 办法 区分 A [ 0 ] , A [ 1 ] … 了 。 
 30 . 在 8086   汇编 下 ， 逻辑 地址 和 物理地址 是 怎样 转换 的 ？ （ Intel ） 
 答案 ： 通用寄存器 给出 的 地址 ， 是 段 内 偏移 地址 ， 相应 段 寄存器 地址 * 10H + 通用寄存器 内 地址 ， 就 得到 了 真正 要 访问 的 地址 。 
 32 . 	 请说出 const 与 # define   相比 ， 有何 优点 ？ 
 答案 ： Const 作用 ： 定义 常量 、 修饰 函数参数 、 修饰 函数 返回值 三个 作用 。 被 Const 修饰 的 东西 都 受到 强制 保护 ， 可以 预防 意外 的 变动 ， 能 提高 程序 的 健壮性 。 
 1 ）   const   常量 有 数据类型 ， 而宏 常量 没有 数据类型 。 编译器 可以 对 前者 进行 类型 安全检查 。 而 对 后者 只 进行 字符 替换 ， 没有 类型 安全检查 ， 并且 在 字符 替换 可能 会 产生 意料不到 的 错误 。 
 2 ）   有些 集成化 的 调试 工具 可以 对 const   常量 进行 调试 ， 但是 不能 对宏 常量 进行 调试 。 
 33 . 简述 数组 与 指针 的 区别 ？ 
 数组 要么 在 静态 存储 区 被 创建 （ 如 全局 数组 ） ， 要么 在 栈 上 被 创建 。 指针 可以 随时 指向 任意 类型 的 内存 块 。 
 ( 1 ) 修改 内容 上 的 差别 
 char   a [ ]   =   “ hello ” ; 
 a [ 0 ]   =   ‘ X ’ ; 
 char   * p   =   “ world ” ;   / /   注意 p   指向 常量 字符串 
 p [ 0 ]   =   ‘ X ’ ;   / /   编译器 不能 发现 该 错误 ， 运行 时 错误 
 ( 2 )   用 运算符 sizeof   可以 计算 出 数组 的 容量 （ 字节数 ） 。 sizeof ( p ) , p   为 指针 得到 的 是 一个 指针 变量 的 字节数 ， 而 不是 p   所指 的 内存容量 。 C++ / C   语言 没有 办法 知道 指针 所指 的 内存容量 ， 除非 在 申请 内存 时 记住 它 。 注意 当 数组 作为 函数 的 参数 进行 传递 时 ， 该 数组 自动 退化 为同 类型 的 指针 。 
 char   a [ ]   =   " hello   world " ; 
 char   * p   =   a ; 
 cout < <   sizeof ( a )   < <   endl ;   / /   12   字节 
 cout < <   sizeof ( p )   < <   endl ;   / /   4   字节 
 计算 数组 和 指针 的 内存容量 
 void   Func ( char   a [ 100 ] ) 
 { 
 cout < <   sizeof ( a )   < <   endl ;   / /   4   字节 而 不是 100   字节 
 } 
 34 . 类 成员 函数 的 重载 、 覆盖 和 隐藏 区别 ？ 
 答案 ： a . 成员 函数 被 重载 的 特征 ： 
 （ 1 ） 相同 的 范围 （ 在 同一个 类中 ） ； 
 （ 2 ） 函数 名字 相同 ； 
 （ 3 ） 参数 不同 ； 
 （ 4 ） virtual   关键字 可有可无 。 
 b . 覆盖 是 指 派生类 函数 覆盖 基类 函数 ， 特征 是 ： 
 （ 1 ） 不同 的 范围 （ 分别 位于 派生类 与 基类 ） ； 
 （ 2 ） 函数 名字 相同 ； 
 （ 3 ） 参数 相同 ； 
 （ 4 ） 基类 函数 必须 有 virtual   关键字 。 
   c . “ 隐藏 ” 是 指 派生类 的 函数 屏蔽 了 与其 同名 的 基类 函数 ， 规则 如下 ： 
 （ 1 ） 如果 派生类 的 函数 与 基类 的 函数 同名 ， 但是 参数 不同 。 此时 ， 不论 有无 virtual 关键字 ， 基类 的 函数 将 被 隐藏 （ 注意 别 与 重载 混淆 ） 。 
 （ 2 ） 如果 派生类 的 函数 与 基类 的 函数 同名 ， 并且 参数 也 相同 ， 但是 基类 函数 没有 virtual   关键字 。 此时 ， 基类 的 函数 被 隐藏 （ 注意 别 与 覆盖 混淆 ） 
 35 . 如何 打印 出 当前 源文件 的 文件名 以及 源文件 的 当前 行号 ？ 
 答案 ： 
 cout   < <   __ FILE __   ; 
 cout < < __ LINE __   ; 
 __ FILE __ 和 __ LINE __ 是 系统 预定 义宏 ， 这种 宏 并 不是 在 某个 文件 中 定义 的 ， 而是 由 编译器 定义 的 。 
 
 
 
 
 
